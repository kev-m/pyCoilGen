import numpy as np
from scipy.optimize import minimize

from typing import List

# Logging
import logging

# Local imports
from sub_functions.data_structures import DataStructure, CoilPart
from sub_functions.constants import get_level, DEBUG_VERBOSE


log = logging.getLogger(__name__)


def stream_function_optimization(coil_parts: List[CoilPart], target_field, input):
    """
    Performs stream function optimization on coil parts.

    Args:
        coil_parts (List[CoilPart]): List of coil parts.
        target_field: Target field.
        input: Input parameters.

    Returns:
        coil_parts (list): Updated coil parts.
        combined_mesh: Combined mesh.
        b_field_opt_sf: Magnetic field generated by optimized stream function.
    """

    tikonov_reg_factor = input.tikonov_reg_factor

    # Combine the matrices from the different mesh parts
    sensitivity_matrix = None            # MATLAB shape: (xyz) x (target field) x (num vertices)
    gradient_sensitivity_matrix = None   # MATLAB shape: ???
    resistance_matrix = None             # MATLAB shape: ???
    current_density_mat = None           # MATLAB shape: (num vertices) x (num faces) x (xyz)

    for part_ind in range(len(coil_parts)):
        coil_part = coil_parts[part_ind]
        if part_ind == 0:
            resistance_matrix = coil_part.resistance_matrix
            current_density_mat = coil_part.current_density_mat
            sensitivity_matrix = coil_part.sensitivity_matrix
            gradient_sensitivity_matrix = sensitivity_matrix
        else:
            # Untested
            resistance_matrix = np.block(
                [
                    [resistance_matrix],
                    [coil_part.resistance_matrix],
                ]
            )
            current_density_mat = np.concatenate(
                [
                    np.block(
                        [
                            current_density_mat[:, :, 0],
                            coil_part.current_density_mat[:, :, 0],
                        ]
                    ),
                    np.block(
                        [
                            current_density_mat[:, :, 1],
                            coil_part.current_density_mat[:, :, 1],
                        ]
                    ),
                    np.block(
                        [
                            current_density_mat[:, :, 2],
                            coil_part.current_density_mat[:, :, 2],
                        ]
                    ),
                ],
                axis=2,
            )
            sensitivity_matrix.append(coil_part.sensitivity_matrix)
            gradient_sensitivity_matrix.append(coil_part.sensitivity_matrix)

    # Generate a combined mesh container
    c_mesh = coil_parts[0].coil_mesh
    combined_mesh = DataStructure(vertices=c_mesh.get_vertices(), faces=c_mesh.get_faces())
    combined_mesh.mesh_part_vertex_ind = np.ones(
        (1, combined_mesh.vertices.shape[0])
    )
    combined_mesh.boundary = c_mesh.boundary

    for part_ind in range(1, len(coil_parts)):
        coil_part = coil_parts[part_ind]
        combined_mesh.faces = np.concatenate(
            [combined_mesh.faces, coil_part.coil_mesh.faces + combined_mesh.vertices.shape[1]], axis=1
        )
        combined_mesh.n = np.concatenate(
            [combined_mesh.n, coil_part.coil_mesh.n], axis=1
        )
        combined_mesh.uv = np.concatenate(
            [combined_mesh.uv, coil_part.coil_mesh.uv], axis=1
        )
        combined_mesh.mesh_part_vertex_ind = np.concatenate(
            [
                combined_mesh.mesh_part_vertex_ind,
                np.ones(
                    (1, coil_part.coil_mesh.vertices.shape[0])
                ) * part_ind,
            ],
            axis=1,
        )

        for boundary_ind in range(len(coil_part.coil_mesh.boundary)):
            combined_mesh.boundary.append(
                coil_part.coil_mesh.boundary[boundary_ind]
                + combined_mesh.vertices.shape[1]
            )

        combined_mesh.vertices = np.concatenate(
            [combined_mesh.vertices, coil_part.coil_mesh.vertices], axis=1
        )

    combined_mesh.bounding_box = np.array(
        [
            [np.min(combined_mesh.vertices[:, 0]), np.max(combined_mesh.vertices[:, 0])],
            [np.min(combined_mesh.vertices[:, 1]), np.max(combined_mesh.vertices[:, 1])],
            [np.min(combined_mesh.vertices[:, 2]), np.max(combined_mesh.vertices[:, 2])],
        ]
    )
    if get_level() >= DEBUG_VERBOSE:
        log.debug(" - combined_mesh.bounding_box: %s", combined_mesh.bounding_box)
    set_zero_flag = False  # Flag to force the potential on the boundary nodes to zero

    # Reduce target field only to z component
    sensitivity_matrix_single = sensitivity_matrix[2]
    target_field_single = target_field.b[2]

    # Reduce the Resistance matrix for boundary nodes
    reduced_res_matrix, _, _ = reduce_matrices_for_boundary_nodes(
        resistance_matrix, combined_mesh, set_zero_flag
    )
    if get_level() >= DEBUG_VERBOSE:
        log.debug(" - reduced_res_matrix shape: %s", reduced_res_matrix.shape)

    # Reduce the sensitivity matrix for boundary nodes
    reduced_sensitivity_matrix, boundary_nodes, is_not_boundary_node = reduce_matrices_for_boundary_nodes(
        sensitivity_matrix_single, combined_mesh, set_zero_flag
    )

    reduced_gradient_sensitivity_matrix_x, _, _ = reduce_matrices_for_boundary_nodes(
        gradient_sensitivity_matrix[0], combined_mesh, set_zero_flag)
    reduced_gradient_sensitivity_matrix_y, _, _ = reduce_matrices_for_boundary_nodes(
        gradient_sensitivity_matrix[1], combined_mesh, set_zero_flag
    )
    reduced_gradient_sensitivity_matrix_z, _, _ = reduce_matrices_for_boundary_nodes(
        gradient_sensitivity_matrix[2], combined_mesh, set_zero_flag
    )

    # Reduce the current density matrix for boundary nodes
    red_current_density_mat_u, _, _ = reduce_matrices_for_boundary_nodes(
        current_density_mat[:, :, 0].T, combined_mesh, set_zero_flag
    )
    red_current_density_mat_v, _, _ = reduce_matrices_for_boundary_nodes(
        current_density_mat[:, :, 1].T, combined_mesh, set_zero_flag
    )
    red_current_density_mat_w, _, _ = reduce_matrices_for_boundary_nodes(
        current_density_mat[:, :, 2].T, combined_mesh, set_zero_flag
    )

    # Scale the tikonov regularization factor with the number of target points and mesh vertices
    tikonov_reg_factor = tikonov_reg_factor * (
        reduced_sensitivity_matrix.shape[0] / reduced_sensitivity_matrix.shape[1]
    )

    if input.sf_opt_method == "tikkonov":
        # Calculate the stream function by the tikonov optimization approach
        tik_reg_mat = tikonov_reg_factor * reduced_res_matrix
        if get_level() >= DEBUG_VERBOSE:
            log.debug(" -- tik_reg_mat shape: %s", tik_reg_mat.shape)
        reduced_sf = np.linalg.pinv(
            reduced_sensitivity_matrix.T
            @ reduced_sensitivity_matrix
            + tik_reg_mat.T
            @ tik_reg_mat
        ) @ reduced_sensitivity_matrix.T @ target_field_single
    else:
        # NOTE: Untested
        # For initialization, calculate the tikkonov solution; then do an iterative optimization
        tik_reg_mat = tikonov_reg_factor * reduced_res_matrix
        reduced_sf = np.linalg.pinv(
            reduced_sensitivity_matrix.T
            @ reduced_sensitivity_matrix
            + tik_reg_mat.T
            @ tik_reg_mat
        ) @ reduced_sensitivity_matrix.T @ target_field_single

        # Find the constrained solution
        stream_func_max = np.max(reduced_sf) * 2
        lb = np.ones_like(reduced_sf) * (-1) * stream_func_max
        ub = np.ones_like(reduced_sf) * stream_func_max

        def cost_function(x):
            return np.sum(
                (reduced_sensitivity_matrix @ x - target_field_single) ** 2
            ) + tikonov_reg_factor * (x.T @ reduced_res_matrix @ x)

        # Define the bounds
        bounds = [(lb[i], ub[i]) for i in range(len(lb))]

        # Define the options
        options = {'disp': True, 'maxiter': input.fmincon_parameter[0], 'maxfev': input.fmincon_parameter[1],
                   'gtol': input.fmincon_parameter[2], 'tol': input.fmincon_parameter[3]}

        # Perform the optimization
        result = minimize(cost_function, reduced_sf, method='SLSQP', bounds=bounds, options=options)
        reduced_sf = result.x

    # Reexpand the stream potential to the boundary nodes
    opt_stream_func = reexpand_stream_function_for_boundary_nodes(
        reduced_sf, boundary_nodes, is_not_boundary_node, set_zero_flag
    )
    combined_mesh.stream_function = opt_stream_func

    # Calculate the magnetic field generated by the optimized stream function
    # MATLAB: (257 x 3)
    b_field_opt_sf = np.vstack(
        (
            sensitivity_matrix[0] @ opt_stream_func,
            sensitivity_matrix[1] @ opt_stream_func,
            sensitivity_matrix[2] @ opt_stream_func,
        )
    ).T

    # Separate the optimized stream function again onto the different mesh parts
    for part_ind in range(len(coil_parts)):
        coil_part = coil_part
        coil_part.stream_function = opt_stream_func[  # 264,
            # IndexError: too many indices for array: array is 1-dimensional, but 2 were indexed
            (combined_mesh.mesh_part_vertex_ind == (part_ind+1))[0]
        ]
        jx = coil_part.stream_function @ coil_parts[
            part_ind
        ].current_density_mat[:, :, 0]
        jy = coil_part.stream_function @ coil_parts[
            part_ind
        ].current_density_mat[:, :, 1]
        jz = coil_part.stream_function @ coil_parts[
            part_ind
        ].current_density_mat[:, :, 2]

        # MATLAB:  (xyz) x (num faces)
        # TODO: Should this be transposed, for Python, or left in MATLAB shape? Depends on later usage...
        coil_part.current_density = np.vstack((jx, jy, jz))

    return coil_parts, combined_mesh, b_field_opt_sf


def reduce_matrices_for_boundary_nodes(full_mat, coil_mesh, set_zero_flag):
    """
    Reduce the sensitivity matrix in order to limit the degrees of freedom on
    the boundary nodes and make sure that they have constant sf later for each boundary.

    Args:
        full_mat: Full matrix to be reduced.
        coil_mesh: Coil mesh.
        set_zero_flag: Flag to force the potential on the boundary nodes to zero.

    Returns:
        reduced_mat: Reduced matrix.
        boundary_nodes: Boundary nodes.
        is_not_boundary_node: Non-boundary nodes.
    """

    num_nodes = coil_mesh.vertices.shape[0]
    dim_to_reduce = [x == num_nodes for x in full_mat.shape]
    num_boundaries = len(coil_mesh.boundary)
    num_nodes_per_boundary = np.array(
        [len(np.unique(coil_mesh.boundary[x])) for x in range(num_boundaries)]
    )

    is_not_boundary_node = np.setdiff1d(
        np.arange(full_mat.shape[1]), np.concatenate(coil_mesh.boundary)
    )
    boundary_nodes = [
        np.unique(coil_mesh.boundary[x]) for x in range(num_boundaries)
    ]
    reduced_mat = full_mat.copy()

    if np.any(dim_to_reduce):
        for dim_to_reduce_ind in np.where(dim_to_reduce)[0]:
            for boundary_ind in range(num_boundaries):
                if set_zero_flag:
                    reduced_mat[boundary_nodes[boundary_ind], :] = 0
                else:
                    Index1 = [slice(None)] * np.ndim(full_mat)
                    Index1[dim_to_reduce_ind] = boundary_nodes[boundary_ind][0]
                    Index2 = [slice(None)] * np.ndim(full_mat)
                    Index2[dim_to_reduce_ind] = boundary_nodes[boundary_ind]  # [:-1]
                    reduced_mat[Index1] = np.sum(tuple(reduced_mat[Index2]), axis=dim_to_reduce_ind)

        boundary_nodes_first_inds = [
            boundary_nodes[x][0] for x in range(num_boundaries)
        ]

        for dim_to_reduce_ind in np.where(dim_to_reduce)[0]:
            prev_reduced_mat = reduced_mat.copy()
            Index1 = [slice(None)] * np.ndim(full_mat)
            Index1[dim_to_reduce_ind] = slice(0, num_boundaries)  # The first entries are substitutes for the boundaries
            Index2 = [slice(None)] * np.ndim(full_mat)
            Index2[dim_to_reduce_ind] = boundary_nodes_first_inds  # Indices of the first nodes of the boundaries
            Index3 = [slice(None)] * np.ndim(full_mat)
            Index3[dim_to_reduce_ind] = slice(num_boundaries, len(
                is_not_boundary_node) + num_boundaries)  # Indices of the non-boundary nodes
            Index4 = [slice(None)] * np.ndim(full_mat)
            Index4[dim_to_reduce_ind] = is_not_boundary_node  # Old non-boundary nodes
            Index5 = [slice(None)] * np.ndim(full_mat)
            Index5[dim_to_reduce_ind] = slice(
                num_nodes - (sum(num_nodes_per_boundary) - num_boundaries), num_nodes)  # Entries to be deleted
            reduced_mat[tuple(Index1)] = prev_reduced_mat[tuple(Index2)]
            reduced_mat[tuple(Index3)] = prev_reduced_mat[tuple(Index4)]
            reduced_mat = np.delete(reduced_mat, Index5[dim_to_reduce_ind], axis=dim_to_reduce_ind)

            if get_level() > DEBUG_VERBOSE:
                log.debug(" -- %d reduced_mat.shape: %s", dim_to_reduce_ind, reduced_mat.shape)

    return reduced_mat, boundary_nodes, is_not_boundary_node


def reexpand_stream_function_for_boundary_nodes(reduced_sf, boundary_nodes, is_not_boundary_node, set_zero_flag):
    """
    Reexpands the stream function to all nodes including the boundary nodes.

    Args:
        reduced_sf (numpy.ndarray): Reduced stream function.
        boundary_nodes (list): List of boundary nodes.
        is_not_boundary_node (numpy.ndarray): Array of non-boundary nodes.
        set_zero_flag (bool): Flag to force the potential on the boundary nodes to zero.

    Returns:
        sf (numpy.ndarray): Expanded stream function.
    """

    # Initialize the expanded stream function with zeros
    sf = np.zeros(
        len(is_not_boundary_node) + sum(len(boundary_nodes[x]) for x in range(len(boundary_nodes))),
        dtype=reduced_sf.dtype,
    )

    # Assign the stream function values for the boundary nodes
    for boundary_ind in range(len(boundary_nodes)):
        if set_zero_flag:
            sf[boundary_nodes[boundary_ind]] = 0
        else:
            sf[boundary_nodes[boundary_ind]] = reduced_sf[boundary_ind]

    # Assign the stream function values for the non-boundary nodes
    sf[is_not_boundary_node] = reduced_sf[len(boundary_nodes):]

    return sf
